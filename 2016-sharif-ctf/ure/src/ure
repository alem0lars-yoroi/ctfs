#!/usr/bin/python


import os, re


# Colors functions.
BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE = range(8)
def colorize(text, color): return "\x1b[1;%dm" % (30 + color) + text + "\x1b[0m"
def print_colored(text, color=WHITE): print(colorize(text, color))


class UREEGR(object):
    def __init__(self, r0, r1):
        self._r0 = r0
        self._r1 = r1

    @property
    def r0(self): return self._r0

    @property
    def r1(self): return self._r1

class UREEGCipherText(object):
    def __init__(self, a, b, c, d, p):
        self.p = p
        self.a = a
        self.b = b
        self.c = c
        self.d = d

    @property
    def a(self): return self._a
    @a.setter
    def a(self, value): self._a = value % self.p

    @property
    def b(self): return self._b
    @b.setter
    def b(self, value): self._b = value % self.p

    @property
    def c(self): return self._c
    @c.setter
    def c(self, value): self._c = value % self.p

    @property
    def d(self): return self._d
    @d.setter
    def d(self, value): self._d = value % self.p

    @property
    def p(self): return self._p
    @p.setter
    def p(self, value): self._p = value

    def __eq__(self, other):
        return (isinstance(other, self.__class__)
            and self.a == other.a
            and self.b == other.b
            and self.c == other.c
            and self.d == other.d)

    def __ne__(self, other):
        return not self.__eq__(other)

class UREEGReEncryptor(object):
    def __init__(self, ciphertext, r):
        self._ciphertext = ciphertext
        self._r          = r

    def encrypt(self):
        return UREEGCipherText(pow(self._ciphertext.a, self._r.r0),
                               pow(self._ciphertext.b, self._r.r0),
                               pow(self._ciphertext.c * self._ciphertext.a,
                                   self._r.r1),
                               pow(self._ciphertext.d * self._ciphertext.b,
                                   self._r.r1),
                               self._ciphertext.p)

def parsecipherfile(name, p=None):
    ciphertext_path = os.path.join(os.path.dirname(os.path.dirname(__file__)),
                                   'data', name)
    pattern = lambda var: re.compile('^{var}\\s*=\\s*0x(.+)$'.format(var=var))
    inputs = {'a': None, 'b': None, 'c': None, 'd': None, 'p': None}
    if p is not None:
        inputs['p'] = p
    with open(ciphertext_path) as f:
        lines = filter(None, f.read().splitlines())
        for line in lines:
            for name in inputs.keys():
                mda = pattern(name).match(line)
                if mda:
                    inputs[name] = int(mda.group(1), 16)
    return UREEGCipherText(inputs['a'], inputs['b'], inputs['c'], inputs['d'],
                           inputs['p'])

def test():
    # Build testing data structures.
    origciphertext = parsecipherfile('ciphertext.txt')
    expectedciphertext = parsecipherfile('solution.txt', p=origciphertext.p)
    r = UREEGR(2, 1)
    encryptor = UREEGReEncryptor(origciphertext, r)
    # ReEncrypt.
    ciphertext = encryptor.encrypt()
    print(hex(ciphertext.a))
    print(hex(ciphertext.b))
    print(hex(ciphertext.c))
    print(hex(ciphertext.d))
    if ciphertext == expectedciphertext:
        print('Valid')
    else:
        print('Invalid')


if __name__ == '__main__':
    print(test())

# vim: set filetype=python :
