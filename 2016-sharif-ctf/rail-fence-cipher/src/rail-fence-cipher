#!/usr/bin/python
# ------------------------------------------------------------------------------
# IMPORTS ----------------------------------------------------------------------

from shared.output import *
from shared.main   import *

# ------------------------------------------------------------------------------
# ALGORITHMS -------------------------------------------------------------------

class RailFenceCipher(object):
    def __init__(self, railsize, verbose=False):
        self._verbose = verbose
        self._railsize = railsize

    def _fence(self, lst):
        fence = [[None] * len(lst) for n in range(self._railsize)]
        rails = (list(range(self._railsize - 1)) +
                 list(range(self._railsize - 1, 0, -1)))
        for n, x in enumerate(lst):
            fence[rails[n % len(rails)]][n] = x

        if self._verbose:
            fence_str = ''
            for rail in fence:
                rail_data = []
                for c in rail:
                    if c is None:
                        rail_data.append(colorize('.', YELLOW))
                    else:
                        rail_data.append(colorize(str(c), BLUE))
                fence_str += ''.join(rail_data) + '\n'
            printdebug('Building rail fence..\n{}'.format(fence_str), indent=3)

        return [c for rail in fence for c in rail if c is not None]

class RailFenceEncoder(RailFenceCipher):
    def __init__(self, plaintext, railsize, verbose=False):
        super(RailFenceEncoder, self).__init__(railsize, verbose=verbose)
        self._plaintext = plaintext

    def encode(self):
        ciphertext = ''.join(self._fence(self._plaintext))
        if self._verbose:
            printsuccess('Encoded plaintext into: {ciphertext}'.format(
                ciphertext=colorize(ciphertext, CYAN)), indent=3)
        return ciphertext

class RailFenceDecoder(RailFenceCipher):
    def __init__(self, ciphertext, railsize, verbose=False):
        super(RailFenceDecoder, self).__init__(railsize, verbose=verbose)
        self._ciphertext = ciphertext

    def decode(self):
        rng = range(len(self._ciphertext))
        positions = self._fence(rng)
        plaintext = ''.join(self._ciphertext[positions.index(n)] for n in rng)
        if self._verbose:
            printsuccess('Decoded ciphertext into: {plaintext}'.format(
                plaintext=colorize(plaintext, CYAN)), indent=3)
        return plaintext

# ------------------------------------------------------------------------------
# TEST FUNCTIONS ---------------------------------------------------------------

def test(verbose):
    railsize = 21
    plaintext  = ('A-fence-is-a-structure-that-encloses-an-area,-SharifCTF'
                  '{QmFzZTY0IGlzIGEgZ2VuZXJpYyB0ZXJt},-typically-outdoors.')
    ciphertext = ('AaY--rpyfneJBeaaX0n-,ZZcs-uXeeSVJ-sh2tioaZ}slrg,-ciE-an'
                  'fGt.-eCIyss-TzprttFliora{GcouhQIadctm0ltt-FYluuezTyorZ-')

    printcolored('<< Testing Fence Cipher encode/decode functions..', BLUE)

    decoded = RailFenceDecoder(ciphertext, railsize, verbose=verbose).decode()
    if plaintext == decoded:
        printcolored('<<< Decode success: plaintext == decoded', GREEN)
    else:
        printcolored('<<< Decode failed: plaintext != decoded', RED)

    encoded = RailFenceEncoder(plaintext, railsize, verbose=verbose).encode()
    if ciphertext == encoded:
        printcolored('<<< Encode success: ciphertext == encoded', GREEN)
    else:
        printcolored('<<< Encode failed: ciphertext != encoded', RED)

# ------------------------------------------------------------------------------
# ENTRY POINT ------------------------------------------------------------------

if __name__ == '__main__':
    parser = argparse.ArgumentParser(prog='rail-fence-cipher',
            description='Rail Fence Cipher')
    parser.add_argument('--verbose', '-v', action='store_true',
            help='Output verbose')
    subparsers = parser.add_subparsers(title='subcommands', dest='parsername')

    # Create the parser for the `test` command.
    parser_test = subparsers.add_parser('test',
            help='Test the Rail Fence algorithm implementation')

    cipher_parser = argparse.ArgumentParser(add_help=False)
    cipher_parser.add_argument('--railsize', '-r', type=int, required=True,
            help='The rail size (number of rows)')
    cipher_parser.add_argument('--literal', '-l', action='store_true',
            help='Interpret input strings as Python literals or normal strings')

    # Create the parser for the `encode` command.
    parser_encode = subparsers.add_parser('encode', parents=[cipher_parser],
            help='Encode the provided plain-text(s)')
    parser_encode.add_argument('PLAINTEXT', nargs='+',
            help='String(s) to be encoded')

    # Create the parser for the `decode` command.
    parser_decode = subparsers.add_parser('decode', parents=[cipher_parser],
            help='Encode the provided cipher-text(s)')
    parser_decode.add_argument('CIPHERTEXT', nargs='+',
            help='String(s) to be decoded')

    # Parse arguments and call the right sub-command function.
    args = parser.parse_args(sys.argv[1:])
    if args.parsername == 'test':
        test(args.verbose)
    elif args.parsername == 'encode':
        print('<<< Encoding plain-text(s)', BLUE)
        for plaintext in args.plaintext:
            if args.literal:
                plaintext = ast.literal_eval(plaintext)
            print(RailFenceEncoder(plaintext, args.railsize,
                                   verbose=args.verbose))
    elif args.parsername == 'decode':
        print('<<< Decoding cipher-text(s)', BLUE)
        for ciphertext in args.ciphertext:
            if args.literal:
                ciphertext = ast.literal_eval(ciphertext)
            print(RailFenceDecoder(ciphertext, args.railsize,
                                   verbose=args.verbose))

# ------------------------------------------------------------------------------
# vim: set filetype=python :
